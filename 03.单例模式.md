## 单例模式详解

### 定义
一个类只能创建一个实例，且该类能自行创建这个实例的一种模式

### 特点
* 单例类只能有一个实例对象
* 该实例对象必须由单例类自行创建
* 单例类对外提供一个访问该单例的全局访问点

### 实现
&emsp;&emsp;普通类的构造函数是公有的`public`，外部类可以通过`new 构造函数`来生成多个实例。但是如果将该类的构造函数声明为私有的`private`，外部类就无法调用该构造函数，也就无法生成实例。这时候类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例

### 应用场景
* 在某一些场景中，某类只要求生成一个对象
* 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如Web中的配置对象、数据库的连接池等。
* 当某类需要被频繁实例化，而创建的对象又被频繁销毁的时候，如多线程的线程池，网络线程池等

### 注意点
* 单例模式的实现方式有多种
* **懒汉模式/恶汉模式**: 存在线程安全的问题
* **加锁**：线程安全，但锁的代价很高。但是如果程序异常，就会导致死锁
* **双检查锁**：由于CPU乱序执行，导致内存读写reorder不安全
* **返回指向局部静态对象的引用**: 由《Effective C++》提出，但是也不是线程安全的。要保证线程安全，必须在主线程开始，其他线程还没有运行的时候先执行静态公有函数，创建静态私有实例，这样就不会在多线程中存在线程安全的问题了
* **pthread_once**：由线程库保证线程安全。程硕在`muduo`网络库中使用。在《Linux高性能服务端编程》一书详细说明了这种用法。